# java面向对象

## 1.static关键字

* 可以修饰**变量**，**方法**，**代码块**，**内部类**，不能修饰**构造方法**。

    * static修饰的成员变量为静态成员变量（类变量）。与类的生命周期相同，是整个应用执行期间。

    * 可以用`对象.静态变量`的方法来获取静态变量，但是不建议。
    
* 访问权限

    * 静态方法不可以访问非静态的方法，变量，也不能访问`this`

    > 可能存在这样一种情况，静态方法已经随类被加载了，但是没有实例化，也就没有成员变量和成员方法，不能读取。

    * 非静态的方法可以访问静态的变量和方法。

    > 因为静态方法已经先于非静态方法被加载进去。

* 存储位置

    * 静态成员变量存储在**方法区**中
    * 实例成员变量存储在**堆内存**上
    
* 代码块（按顺序自动执行，不可以被调用）

    * 局部代码块（方法内）
    
    局部代码块定义的变量作用范围只限于代码块以内。
    
    * 成员代码块（类内）
    
    执行时间先于构造方法。依照代码块的顺序执行，运用很少（可用于匿名内部类，将初始化代码放入代码块里）
    
    * static代码块
    
    在类第一次加载的时候，执行static代码块（只一次）。运用比较多，**可以用于执行全局化的初始化操作**，比如创建工厂和加载数据库初始信息。

##  2.生成DOC文档（IDEA）

Tools-->Generate Java

![alt 生成DOC](\Generate_JavaDoc.png)

## 3.权限修饰符

| ***修饰符*** | ***同一个类*** | ***同一个包中(同包可继承)*** | ***子类***  | ***所有包的所有类*** |
| :----------: | :------------: | :--------------------------: | :---------: | :------------------: |
|   private    |  ***\**\****   |                              |             |                      |
| 默认/default |  ***\**\****   |         ***\**\****          |             |                      |
|  protected   |  ***\**\****   |         ***\**\****          | ***\**\**** |                      |
|    public    |  ***\**\****   |         ***\**\****          | ***\**\**** |     ***\**\****      |

## 4.this关键字

创建对象分为一下四步：

 	1.分配对象空间，将对象成员初始化为null或0；  

 	2.执行属性值显示初始化；  

 	3.执行构造方法；

 	4.返回对象的地址给相关变量。

**this 是指创建好的对象的地址。**

**可以使用this调用构造方法来实现重载的功能，但是必须放在第一行。**

## 5.继承

* 子类继承了父类的全部方法（**除了构造方法**）和属性，但是不一定可以访问。

* 子类重写了的父类的方法，其访问权限修饰符的范围不能小于父类。



## 6.多态

父类能出现的地方，子类一般也能出现，子类出现的地方，父类不能出现。

* 向上转型 
* 向下转型 需要强制类型转换。（转换后仍然有可能报错）

## 7.代码块

在有继承情况时，

父类子类都有 **静态代码块** ，**普通代码块** ，**构造方法**时，加载的顺序是：

​	父类静态代码块 --> 子类静态代码块 --> 父类普通代码块 -->  父类构造方法 --> 子类普通代码块 -->子类构造方法，例如：

<img src="C:\Users\邓小兵\Documents\我的Java笔记\Static_Block_list.png" alt="执行顺序" style="zoom:60%;" />

## 8.接口

1. 用static修饰的方法必须要写方法体，子类实例可以调用此静态方法；

   static修饰的属性必须是静态常量，子类实例不可调用，子类可以调用。

2. 1.8之前：接口的属性都是静态常量（static final），方法不可以使用static修饰。

3. 实现类需要实现接口中定义的所有抽象方法。

### 1.在JDK1.7以前的接口的变量。

都是`public static final  ` ,全局静态常量。

接口内都是abstract方法，不可以使用`static`修饰（abstract与static ,final ,private不能共存）

### 3.接口中可以添加非抽象方法（default）。

实现类可以重写，但是必须去掉（default）,只能通过对象名调用。不可以使用`接口名.方法`调用。

```java
interface Father{
    
    default void getName(){
        System.out.println("接口的default方法");
    }
}
class Son implements Father {

    @Override
    public void getName() {
		System.out.println("实现类重写了接口的default方法");
    }
}
```

> 在JDK9及其以后，接口可以定义private的非抽象方法，便于多个方法的提取冗余代码。同时也实现了代码隐藏。

## 9.抽象类

实现类一定要重写全部的抽象方法。

抽象类可以有非抽象方法。

## 10.内部类

内部类的特征：

可以使用四个权限修饰符；

外部类是不能直接使用内部类的成员变量和成员方法的；

1. **静态成员内部类**

   实例化的格式是：

```java
外部类.静态内部类 对象名 = new 外部类.静态内部类();
```

2. **非静态成员内部类**（局部内部类）

   内部类可以直接使用外部类的成员变量和成员方法；

   区分外部类和内部类的同名变量是`外部类名.this.变量名`；

3. **局部内部类**（这个类在方法体里面）

   使用final关键字修饰，可不写。

4. **匿名内部类**（直接new 接口/抽象类(){//内部实现}）

   内部类简化写法，是一种特殊的局部内部类。

## 11.异常

### 1.try……catch……finally标准结构

​	try用来包裹住需要捕获的代码；catch用来匹配异常对象进行处理；finally是在不论是否执行catch，都会执行finally后面的代码。而且可以在return执行完成后，继续执行finally里的语句代码。

### 2.检查时异常和运行时异常的区别？？ 

1. **检查时异常**：必须捕获进行处理，不捕获不能运行。

	2. **运行时异常**：不一定要进行处理，系统自动检测进行处理。

### 3.异常 可以手动抛出。

```java
throw new Exception();
//throws是方法和类用来向上抛出异常。
//throw是用在语句前面的。
```

## 12.类于类之间的关系

1. **继承**（也叫泛化，Generalization）

   extends，不多说。

2. **实现**（Realization）

   implements，也不多说。

3. **依赖**（Dependency）

   弱关系，这种关系具有偶然性，临时性，一个类作为另一个类的方法参数或者局部变量。

4. **关联**（Association）

   强于依赖关系，属于必然的，长期的，强烈的，（个人理解是成员变量的关系。）

5. **聚合**（Aggregation）

   一种关联关系的特例，是整体和部分的关系。

6. **组合**（Composition）

   一种关联关系的特例，强于聚合，不可分割的部分。

## 13.面向对象设计原则

7种原则：

1. **单一职责原则**：系统中的每一个类都应该是只有一个职责。

2. **开闭原则**：软件实体应该对扩展开放，对修改关闭；即引入新功能而不改变原代码。

3. **里氏替代原则**：父类可以出现的地方，则子类也可以出现。反过来不一定了。

4. **依赖倒置原则**：通过抽象（抽象类或则接口）来使各个类和模块的实现相互独立，互不影响。

5. **接口分离原则**：客户端不应该强行依赖它不需要的接口，类间的依赖应该建立在最小的接口上。

6. **迪米特法则**：如果两个类不必直接通信，则就不应该发生直接互相作用；如果一个类需要用到这里的另一个类，则可以通过第三者转发这个调用。
7. **合成聚合原则**：优先使用对象组合，而不是类继承。

